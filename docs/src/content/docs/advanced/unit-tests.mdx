---
title: Testing
description: About how to use the testing suite in CrabRolls.
sidebar:
    order: 0
---

import { Steps, Aside } from '@astrojs/starlight/components';

Unit testing is an essential part on creating your own dApp, ensuring your code behaves as expected before deploying it. In CrabRolls, you can create comprehensive unit tests to validate your dApp's functionality. This guide will walk you through the process of setting up and writing unit tests for your dApp.

<Aside>
	All the tests are executed in a simulated environment / locally, so you don't need to be running a host machine like [Nonodo](https://github.com/Calindra/nonodo/). Because of that, you can run the
	tests in your local machine without any additional setup or dependencies and validate your application's behavior.
</Aside>

### Writing Your First Unit Test

<Steps>
1. **Create a New Test Module:**
   Inside your application code, typically at the bottom of your `source code` or in a separate `tests` module, you can define your tests.

    ```rust
    #[cfg(test)]
    mod tests {
        use super::*; // You also can import specific items from
                      // your application instead of using `super::*`.
        use crabrolls::prelude::*; // Import all utilities from CrabRolls
    }
    ```

2.  **Define a Test Function:**
    Tests in CrabRolls are asynchronous. Use the `async_std::test` attribute to define an async test function.

    ```rust
    #[async_std::test]
    async fn test_my_app() {
        // Test logic goes here
    }
    ```

3.  **Create an Application Instance:**
    Instantiate your application within the test function.

    ```rust
    let app = MyApp::new();
    ```

4.  **Create a Tester Instance:**
    Use the `Tester` utility to create a tester from your application instance. The tester helps you simulate and validate the application's behavior.

    ```rust
    let tester = Tester::new(app);
    ```

5.  **Prepare Input Payload:**
    Next, prepare the input payload for the application based on the test scenario.

    ```rust
    let payload = b"Hi Crabrolls!".to_vec();
    ```

6.  **Simulate Application Advance:**
    Use the tester to advance the state of your application with the prepared payload.

    ```rust
    let result = tester.advance(Address::default(), payload).await;
    ```

    and you can do the same for inspect the application state:

    ```rust
    let result = tester.inspect(payload).await;
    ```

7.  **Validate Test Results:**
    Check the results of the advance operation. Validate the status, errors, and outputs to ensure the application behaves as expected.

    the output of the `advance` and `inspect` is a object with the main fields to verify the application status, errors and outputs. Current the `Result` object has the following fields:

    -   `status`: The status of the application after the advance operation.
    -   `error`: An optional error message if the application failed.
    -   `outputs`: A vector of outputs generated by the application.
    -   `metadata`: A metadata object with additional information about the application advance (Only available in the `advance` operation).
        -   `input_index`: The index of the input that was processed.
        -   `sender`: The address of the sender of the input.
        -   `block_number`: The block number of the application.
        -   `timestamp`: The timestamp of the input processing.

    You can see more details about the `Result` object in the [Testing Types Source code](https://github.com/crabrolls-cartesi/crabrolls/blob/main/src/types/testing.rs).

    ```rust
    // Check the status of the result
    assert_eq!(result.status, FinishStatus::Accept, "Expected Accept status");

    // Check if there are any errors
    assert!(result.error.is_none(), "Unexpected error: {:?}", result.error);

    // Validate the outputs length
    assert_eq!(
            result.outputs.len(),
            3,
            "Expected 3 outputs, got {}",
            result.outputs.len()
        );

    // Validate the outputs content
    assert_eq!(
            result.outputs,
            vec![
                Output::Notice {
                    payload: payload.clone()
                },
                Output::Report {
                    payload: payload.clone()
                },
                Output::Voucher {
                    destination: address,
                    payload: payload.clone()
                }
            ],
            "Unexpected outputs: {:?}",
            result.outputs
        );

    // Validate the sender address
    assert_eq!(
        result.metadata.sender,
        Address::default(),
        "Unexpected sender address"
    );
    ```

</Steps>

### Complete test case example

Here's an example of a complete test case following the steps above for a echo application like the [Echo example](../../getting-started/examples/echo):

```rust showLineNumbers title="echo_tests.rs"
#[cfg(test)]
mod tests {
    use super::*; // Import all items needed for the tests
    use crabrolls::prelude::*; // Import all utilities from CrabRolls

    #[async_std::test]
    async fn test_my_echo_app() {
        // Create an instance of your application
        let app = MyApp::new();

        // Create a tester instance
        let tester = Tester::new(app);

        // Prepare input payload
        let payload = b"Hi Crabrolls!".to_vec();

        // Simulate application advance
        let result = tester.advance(Address::default(), payload).await;

        // Validate test results
        assert_eq!(result.status, FinishStatus::Accept, "Expected Accept status");
        assert!(result.error.is_none(), "Unexpected error: {:?}", result.error);
        assert_eq!(
            result.outputs.len(),
            3,
            "Expected 3 outputs, got {}",
            result.outputs.len()
        );
        assert_eq!(
            result.outputs,
            vec![
                Output::Notice {
                    payload: payload.clone()
                },
                Output::Report {
                    payload: payload.clone()
                },
                Output::Voucher {
                    destination: address,
                    payload: payload.clone()
                }
            ],
            "Unexpected outputs: {:?}",
            result.outputs
        );
        assert_eq!(
            result.metadata.sender,
            Address::default(),
            "Unexpected sender address"
        );
    }
}
```

### Running Tests

To run your tests, you can use the `cargo test` command. This command will compile your application and run all the tests defined in your application.

```bash title="Terminal"
cargo test
```

The output will show the results of each test, including the status and any errors encountered during the test execution.

```bash title="Terminal"
   Compiling dapp v0.1.0 (/path/to/dapp)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.92s
     Running unittests src/main.rs (target/debug/deps/dapp-xxx)

running 1 test
test tests::test_my_echo_app ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```
